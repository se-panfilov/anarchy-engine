import { promises as fs } from 'node:fs';
import path from 'node:path';
import url from 'node:url';

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, '..');

const { Locales } = await import(path.join(ROOT, 'Scripts', 'locales.config.js'));

const isScript = (sub) => /^[A-Z][a-z]{3}$/.test(sub); // Latn, Cyrl, Hans, Hant...
const isRegion = (sub) => /^([A-Z]{2}|\d{3})$/.test(sub); // US, GB, NL, 419...

const parseParts = (tagRaw) => {
  const tag = tagRaw.trim().replace(/_/g, '-');
  const [langRaw, ...rest] = tag.split('-');
  const language = (langRaw || '').toLowerCase();
  let script;
  let region;
  for (const subRaw of rest) {
    if (!script && isScript(subRaw)) {
      script = subRaw[0].toUpperCase() + subRaw.slice(1).toLowerCase();
      continue;
    }
    if (!region && isRegion(subRaw)) {
      region = subRaw.toUpperCase();
      continue;
    }
  }
  return { language, script, region };
};

const canonicalize = (tag) => {
  try {
    const [c] = Intl.getCanonicalLocales(tag);
    if (c) return c;
  } catch {}
  const p = parseParts(tag);
  return [p.language, p.script, p.region].filter(Boolean).join('-');
};

// A minimal set of RTL scripts (extend if needed)
const RTL_SCRIPTS = new Set(['Arab', 'Hebr', 'Syrc', 'Thaa', 'Nkoo', 'Adlm', 'Rohg']);
// Some languages are RTL regardless of missing script in tag
const RTL_LANGS = new Set(['ar', 'fa', 'he', 'ur', 'ps', 'dv', 'ku']);

const inferDirection = (language, script) => ((script && RTL_SCRIPTS.has(script)) || RTL_LANGS.has(language) ? 'rtl' : 'ltr');

const dn = (locales, type) => new Intl.DisplayNames(locales, { type });

const buildEnglishName = (id, p) => {
  // Compose like "Chinese (Simplified, China)" or "English (US)" or "Arabic (Saudi Arabia)"
  const enLang = dn('en', 'language').of(p.language) ?? p.language;
  const bits = [];
  if (p.script) {
    const enScript = dn('en', 'script').of(p.script) ?? p.script;
    bits.push(enScript);
  }
  if (p.region) {
    const enRegion = dn('en', 'region').of(p.region) ?? p.region;
    bits.push(enRegion);
  }
  return bits.length ? `${enLang} (${bits.join(', ')})` : enLang;
};

const buildNativeName = (id, p) => {
  // Use the locale itself for native display where possible
  let langName;
  try {
    langName = dn(id, 'language').of(p.language);
  } catch {}
  if (!langName) {
    // Fallback to language self-name (best-effort)
    try {
      langName = dn(p.language, 'language').of(p.language);
    } catch {}
  }
  langName ||= p.language;

  const bits = [];
  if (p.script) {
    let s;
    try {
      s = dn(id, 'script').of(p.script);
    } catch {}
    s ||= p.script;
    bits.push(s);
  }
  if (p.region) {
    let r;
    try {
      r = dn(id, 'region').of(p.region);
    } catch {}
    r ||= p.region;
    bits.push(r);
  }
  return bits.length ? `${langName} (${bits.join(', ')})` : langName;
};

const buildLocale = (rawId) => {
  const id = canonicalize(rawId);
  const p = parseParts(id);
  if (!p.language) throw new Error(`Invalid locale id: "${rawId}"`);
  const dir = inferDirection(p.language, p.script);
  return {
    id,
    languageCode: p.language,
    regionCode: p.region,
    scriptCode: p.script,
    englishName: buildEnglishName(id, p),
    nativeName: buildNativeName(id, p),
    dir
  };
};

const locales = Locales.map(buildLocale);

const outPath = path.join(ROOT, 'src/Constants', 'Locales.gen.ts');
const header = ['/* AUTO-GENERATED by GenerateLocales.js script â€” do not edit manually. */', '\n'].join('\n');

const toTs = (l) => {
  const json = JSON.stringify(l, null, 2)
    .replace(/"([a-zA-Z0-9_]+)":/g, '$1:') // unquote keys (pretty)
    .replace(/"ltr"|\"rtl\"/g, (m) => m); // keep as strings
  return json;
};

function kebabToCamel(input) {
  if (!input.includes('-')) return input;

  return input
    .toLowerCase()
    .split('-')
    .map((part, index) => (index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)))
    .join('');
}

const body = `${locales.map((l) => `export const ${kebabToCamel(l.id)} =  ` + toTs(l)).join(';\n\n')};\n\n`;

await fs.mkdir(path.dirname(outPath), { recursive: true });
await fs.writeFile(outPath, header + body, 'utf8');

process.stdout.write(`Generated ${path.relative(ROOT, outPath)} with ${locales.length} locales.\n`);
